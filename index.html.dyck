<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Comby〔 Rewrite Code 〕</title>

    <!-- Custom fonts for this theme -->
    <link href="vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">

    <!-- Theme CSS -->
    <link href="css/freelancer.min.css" rel="stylesheet">

    <!-- Source Sans Pro font -->
    <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,300italic,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet">

    <link rel="icon" href="img/favicon.ico" type="image/x-icon/">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-142487942-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-142487942-1');
    </script>

  </head>

  <body id="page-top">

    <!-- Masthead -->
    <header class="masthead bg-primary text-center">
      <div class="container masthead-container d-flex align-items-center flex-column">

        <!-- Masthead Avatar Image -->
        <!--<img class="masthead-avatar mb-5" src="img/avataaars.svg" alt="">-->

        <!-- Masthead Heading -->
        <h1 class="masthead-heading text-uppercase mb-0">Comby</h1>


        <!-- Line -->
        <div class="divider-line"></div>

        <!-- Masthead Subheading -->
        <p class="masthead-subheading font-weight-light mb-0"><code><span class="hole">a tool for changing :[code]</span></code></p>
      </div>

      <!-- Panel -->
      <div class="container media-width-override mt-5 pl-5 pr-5">
        <div class="row">

          <!-- Basic Usage -->
          <div class="col-sm-2 offset-sm-1 panel-item">
            <a href="#basic-usage">
              <div class="mastpanel-item">
                <div class="mastpanel-item-overlay h-100 w-100">
                  <img class="img-fluid" src="img/panel/hexa-cell-1-orange.svg" alt="">
                  <p>Basic Usage</p>
                </div>
                <img class="img-fluid" src="img/panel/hexa-cell-1.svg" alt="">
                <p>Basic Usage</p>
              </div>
            </a>
          </div>

          <!-- Advanced Usage -->
          <div class="col-sm-2 panel-item">
            <a href="#advanced-usage">
              <div class="mastpanel-item">
                <div class="mastpanel-item-overlay h-100 w-100">
                  <img class="img-fluid" src="img/panel/hexa-cell-2-orange.svg" alt="">
                  <p>Advanced Usage</p>
                </div>
                <img class="img-fluid" src="img/panel/hexa-cell-2.svg" alt="">
                <p>Advanced Usage</p>
              </div>
            </a>
          </div>

          <!-- Catalog -->
          <div class="col-sm-2 panel-item">
            <a href="https://catalog.comby.dev/">
              <div class="mastpanel-item">
                <div class="mastpanel-item-overlay h-100 w-100">
                  <img class="img-fluid" src="img/panel/reading-book-orange.svg" alt="">
                  <p>Catalog</p>
                </div>
                <img class="img-fluid" src="img/panel/reading-book.svg" alt="">
                <p>Catalog</p>
              </div>
            </a>
          </div>

          <!-- Live -->
          <div class="col-sm-2 panel-item">
            <a href="https://bit.ly/2UXkonD">
              <div class="mastpanel-item">
                <div class="mastpanel-item-overlay h-100 w-100 fucksakes">
                  <img class="img-fluid" src="img/panel/code-inspector-ui-orange.svg" alt="">
                  <p>Live</p>
                </div>
                <img class="img-fluid" src="img/panel/code-inspector-ui.svg" alt="">
                <p>Live</p>
              </div>
            </a>
          </div>

          <!-- GitHub -->
          <div class="col-sm-2 panel-item">
            <a href="https://github.com/comby-tools/comby/">
              <div class="mastpanel-item mx-auto">
                <div class="mastpanel-item-overlay h-100 w-100">
                  <img class="img-fluid" src="img/panel/github-orange.svg" alt="">
                  <p>GitHub</p>
                </div>
                <img class="img-fluid" src="img/panel/github.svg" alt="">
                <p>GitHub</p>
              </div>
            </a>
          </div>
        </div>
      </div>
    </header>

    <!-- Philosophy Section -->
    <section class="page-section bg-secondary portfolio" id="philosophy">
      <div class="container">
        <!--<h2 class="page-section-heading text-center">Philosophy</h2>-->

        <!-- Line -->
        <div class="d-flex align-items-center flex-column">
          <div class="divider-line"></div>
        </div>

        \p{Code is so interesting because simple linear sequences of characters
      express rich non-linear structures (like trees) and arbitrary information
      (like comments). Humans are very creative, and have developed a variety of
      ways to order these characters to mean different things. For example,
      C-like comments can start with \source{//} but Python-like comments use
      \source{#}. Problematically, we use the same characters to mean different
      things across languages and in different contexts: a \source{#} in C could
      be the start of a macro. Or it could be part of a string like
      \source{"#"}. Or it could be a meaningless character inside a C comment
      like \source{// #}. Yet at some level, a choice of characters in all
      languages correspond to similar underlying structures or information: most
      languages have comments and balanced delimiters like parentheses
      \source{()} or braces \source{{}} nest expressions, as found in typical
      if-statements. The key idea in Comby is to match code that respects the
      basics of this richer structure on a per-language basis, and not (only) as
      arbitrary sequences of characters. Matching sequences of characters is
      something that regex is really good for, but regex is not generally
      powerful enough to recognize nested code structures. Regex also supports a
      lot of additional functionality that can lead to complex patterns. Comby
      tries to cut down on this complexity to make changing code easy, so you'll
      find that regex-style match operators are absent in Comby. And that's OK.}

        <!-- Line -->
        <div class="d-flex align-items-center flex-column">
          <div class="divider-line"></div>
        </div>

      </div>
    </section>

    <!-- Basic Usage Section -->
    <section class="page-section bg-primary portfolio" id="basic-usage">
      <div class="container">

        <!-- Section Heading -->
        <h2 class="page-section-heading text-center">Basic Usage</h2>

        <!-- Line -->
        <div class="d-flex align-items-center flex-column">
          <div class="divider-line"></div>
        </div>

        \p{Comby is a tool for matching and rewriting code. You start by writing
        a simple template to match syntax. Look at this Go function:}

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
```source func main() {
    fmt.Println("hello world")
}
```
          </div>
        </div>

        \p{We can match the arguments to \source{fmt.Println} with this <i>match
        template</i>:}

        <div class="row">
          <div class="col-sm-6 offset-sm-3">
```match
fmt.Println(:[arguments])
```
          </div>
        </div>

            \p{The :[arguments] part is called a hole. It saves the matched part
            to a variable. In this case, the variable is
            called <code>arguments</code>, but we could have called it something
            else, like :[1] or :[the_1st_arg]. Your choice! As long as it only
            contains alphabet characters, numbers, or underscores.}

            \p{The :[arguments] hole matches the \source{"hello world"} string.
            We can use it in a <i>rewrite template</i> to rewrite the function,
            like this one:}

        <div class="row">
          <div class="col-sm-8 offset-sm-2">
```rewrite
fmt.Println(fmt.Sprintf("comby says %s", :[arguments]))
```
          </div>
        </div>

        \p{Comby takes the match and rewrite templates and replaces the matched
        part in place:}

        <div class="row">
          <div class="col-sm-8 offset-sm-2">
```source
func main() {
  \rewrite{fmt.Println(fmt.Sprintf("comby says %s", "hello world"))}
}
```
[Live example](https://bit.ly/2XpttJG)
          </div>
        </div>

        \p{Holes are the only special part in match templates, and they always
        have the form \color{:[...]}[orange]. <u>All other characters are
        interpreted literally</u> (there's a bit of detail about whitespace that
        we'll talk about in the next part). The point is that you <u>never</u>
        have to escape any characters in your template. Just say what you mean!}

        \h6{How Matching Works}[#how-matching-works] \p{:[hole] matches all
        characters, including newlines. If the match template
        was <i>just</i><br> :[file_content], it would match all the file
        content. The way :[hole] starts and stops matching depends on the code
        structure around it. Let's look at an example, matching on this
        Javascript code using the match template on the right:}

        <div class="row">
          <div class="col-sm-5 offset-sm-2">
```source
if (width <= 1280 && height <= 800) {
    return 1;
}
```
[Live example](https://bit.ly/2Xiw1cf)
          </div>

          <div class="col-sm-3">
```match
if (:[var] <= :[rest])


```
          </div>
        </div>

        \p{:[var] matches until it sees the \source{&nbsp;<=&nbsp;} part coming
        after it and matches \match{width}. :[rest] matches the rest of the
        condition: \match{1280 && height <= 800}. These holes match lazily: they
        look for the shortest way to satisfy the match. One way to refine
        matching is to add concrete context around holes based on what we care
        about. For example, we could match \match{height} to :[height] with both
        of the following templates, which depends on matching different parts of
        surrounding code:}

        <div class="row">
          <div class="col-sm-4 offset-sm-2">
```match
if (:[_] && :[height] :[_])
```
          </div>
          <div class="col-sm-4">
```match
if (:[_] :[height] <= 800)
```
          </div>
        </div>

        \h6{About whitespace}[about-whitespace]
        \p{Comby tries to make matching
        code forgiving. Whitespace in the template, like a single space,
        multiple contiguous spaces, or newlines are interpreted all the same:
        Comby will match the corresponding whitespace in the source code, but
        will not care about matching the exact number of spaces, or distinguish
        between spaces and newlines. Not being strict about whitespace tends to
        be the right default decision for code in most languages. It means our
        previous match templates all still work in these cases where our
        Javascript code is formatted differently:}

      <div class="row">
        <div class="col-sm-4 offset-sm-2">
```source
if (width <= 1280
    && height <= 800) {
    return 1;
}
```
[Live example](https://bit.ly/2Xh2tMk)
        </div>
        <div class="col-sm-4">
```source
if (width     <= 1280
    && height <= 800) {
    return 1;
}
```
[Live example](https://bit.ly/2XaGTZV)
          </div>
      </div>

      \p{If you're wondering about indentation-sensitive languages like Python,
      be sure to check out the [FAQ]{#faq-what-about-python}.}

      \h6{What makes Comby special: More about structural matching}[what-makes-comby-special]

      \p{If holes only matched lazily and indiscriminately up to patterns
      like \source{<=} it wouldn't be much more special than matching a sequence
      of characters. But matching is smarter than that. In many languages,
      balanced delimiters like \source{()}, \source{[]} and \source{{}}
      are <u>always</u> balanced. By default, a match template like
      \match{(:[1])} will only match characters <u>inside well-balanced
      parentheses</u>. Here are two example matches in this code:}

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
```source
result = foo\match{(\color{bar(x)}[orange])} + foobar\match{(\color{baz(x)}[orange])};
```
[Live example](https://bit.ly/2Xm12Mk)
          </div>
        </div>

        \p{The hole binds to \source{bar(x)} and \source{baz(x)} respectively,
        which we can easily rewrite to a different call \source{qux(x)}, for
        example. The observant reader will notice that
        \source{(\color{x}[orange])} are nested matches. By default, Comby will
        match at the toplevel, but nested matches can be found with added
        context (e.g., \match{bar(:[1])}), or by extracting and rerunning Comby
        on modified code. Note that writing a regular expression to do the same
        is not easy (simple attempts like \source{\(.*\)}
        <sup>[[]](https://regexr.com/4fssh)</sup> or \source{\(.*?\)}
        <sup>[[]](https://regexr.com/4fssk)</sup> don't work).}

        \p{Let's change the code above and make it a little more interesting.
        Suppose it was this Javascript:}

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
```source
var result = foo(bar(x \color{/* arg 1\unbalanced_right_paren */}[#e2c211])) + foobar(\color{"\unbalanced_left_paren"}[#e2c211]);
```
          </div>
        </div>

        \p{Now there's quite a bit of complexity if we want to match the
        arguments of \source{foo} and \source{foobar}. A block comment
        \source{\color{/* arg 1\unbalanced_right_paren */}[#e2c211]} is inlined
        for \source{bar}. Because this is a comment, it shouldn't matter whether
        the parenthesis inside are balanced or not. The same goes for the string
        literal argument to \source{foobar}: it's not a parenthesis in the code.
        The special thing here is that our original match template
        \match{(:[1])} can stay <u>exactly the same</u> and still matches the
        two arguments (in this case, it captures the comment and string)}

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
```source
var result = foo\match{(\color{bar(x /* arg 1\unbalanced_right_paren */)}[orange])} + foobar(\match{\color{"\unbalanced_left_paren"}[orange]});
```
[Live example](https://bit.ly/2Zy5PYG)
          </div>
        </div>

        \p{Comby understands this interaction between delimiters, strings, and
        comments and makes reasonable guesses for your language based on file
        extension (you can also force a particular matcher with a command line
        option, see the [Quick Reference]{#quick-reference}). And, you can
        always fall back to a generic matcher for files or languages that are
        not explicitly supported. See the [FAQ]{#faq-language-support} for
        language support and extension.}

        \p{Note that if we tried to use a regex above, our pattern would need to
        understand that \source{/* */} delineates comments, otherwise it would
        get confused by the parenthesis inside! The same problem comes up for
        the string literal argument, which contains an unbalanced parenthesis. A
        regular expression that takes all of this into account would get ugly
        fast, and that's only for Javascript!}

        \h6{Match Syntax Reference}[match-syntax]
        \p{The following syntax is
        supported in Comby, and carry special meaning for matching:}

        \p{\source{:[hole]} matches zero or more <i>well-balanced</i> characters
        until the part that comes after the hole (like whitespace, or some other
        string) in a lazy fashion. When :[hole] is inside delimiters, as in
        `(:[hole])`, it matches (only) within those delimiters.}

        \p{\source{\color{:[[hole]]}[orange]} matches one or more alphanumeric
        characters and `_`.}

        \p{\source{\color{:[hole.]}[orange]} (with a period at the end) matches
        one or more alphanumeric characters and punctuation (like `.`, `;`, and
        `-`).}

        \p{\source{\color{:[hole\n]}[orange]} (with a `\n` at the end) matches one or more
        characters up to a newline, including the newline.}

        \p{\source{\color{:[ ]}[orange]} (with a space) matches only whitespace
        characters, excluding newlines. To assign the matched whitespace to
        variable, put the variable name after the space, like \color{:[
        hole]}[orange].}


        \h6{A few more tips and tricks}[tips-and-tricks]

        \p{\color{<i class="fas fa-lightbulb"></i>&nbsp;}[orange] Using :[hole] inside
        string quotes will match only within the string. This is implemented for
        [most languages]{#faq-language-support}. Comby also understands the
        difference between escapable string literals (like
        `"string"` in C) and raw string literals (like
        `\backtickstring\backtick` in Go), and will know to stop between these
        delimiters. <sup>[[]](https://bit.ly/2WRnxEL)</sup>}

        \p{\color{<i class="fas fa-lightbulb"></i>&nbsp;}[orange]
        Use \color{:[[hole]]}[orange] to match only alphanumeric and
        underscore characters. This hole does not match across newlines or
        punctuation.<sup>[[]](https://bit.ly/2WUhPCa)</sup>}

        \p{\color{<i class="fas fa-lightbulb"></i>&nbsp;}[orange]
        You can refer to the same variable using either
        \color{:[[hole]]}[orange] or :[hole] in the rewrite template.
        <sup>[[]](https://bit.ly/2ZAQZR0)</sup>}

        \p{\color{<i class="fas fa-lightbulb"></i>&nbsp;}[orange]
        You almost never want to start a template with :[hole], since it
        matches everything including newlines up to its suffix. This can make
        things slow. :[hole] is typically useful inside balanced delimiters.<sup>[[]](https://bit.ly/2WVDzh7)</sup>}

        \p{\color{<i class="fas fa-lightbulb"></i>&nbsp;}[orange] Consider
        combinations of holes to match interesting properties. For example, to
        capture leading indentation of a line, use a template like <br>\color{:[
        leading_indentation]:[everything_until_newline\n]}[orange].<sup>[[]](https://bit.ly/31uC6RE)</sup>}

        \p{\color{<i class="fas fa-lightbulb"></i>&nbsp;}[orange] Looking for
        inspiration? Check out these simple code
        rewrites<sup>[[]](https://catalog.comby.dev/)</sup> and the [FAQ]{#faq-applications}.}

        </div>
      </div>

  </section>

  <!-- Advanced Usage Section -->
  <section class="page-section bg-secondary portfolio" id="advanced-usage">
    <div class="container">

      <!-- Section Heading -->
      <h2 class="page-section-heading text-center">Advanced Usage</h2>

      <!-- Line -->
      <div class="d-flex align-items-center flex-column">
        <div class="divider-line"></div>
      </div>

      \p{You can refine matches and rewrite templates with <i>rules</i> in Comby. Rules start with the word \source{where}. A rule can check whether two variables are syntactically equal. For example, we can check for duplicate expressions in if-conditions with the following match template and rule:}

        <div class="row">
          <div class="col-sm-8 offset-sm-2">
```match
if (:[left_side] && :[right_side])
```
          </div>
        </div>

        <div class="row">
          <div class="col-sm-4 offset-sm-2">
```source
where :[left_side] == :[right_side]
```
          </div>
        </div>

\p{This matches code where the programmer perhaps made a mistake and duplicated an expression without changing a variable like \source{x} to \source{y}:}

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
```source
if (\match{x == 500} && \match{x == 500})
```
[Live example](https://bit.ly/2Na9UAS)
          </div>
        </div>

        \p{You can use the \source{!=} operator to check inequality. Multiple conditions can be separated by a comma, and mean "logical and". The following adds a condition to ignore our match case above:}

        <div class="row">
          <div class="col-sm-8 offset-sm-2">
```source
where :[left_side] == :[right_side], :[left_side] != \color{"x == 500"}[#e2c211]
```
[Live example](https://bit.ly/2NaaCOy)
          </div>
        </div>

        \p{Variables can be compared to other variables or string contents (enclosed by double quotes).}

        \h6{Experimental language features}[experimental-language-features]

        \p{Comby includes experimental language features for sub-matching and rewriting in rules. These features might change slightly in meaning or syntax, but are currently available if you want to experiment with it.}

        \ph{\color{Sub-matching syntax}[orange]}[experimental-language-features-sub-matching]

        \p{Here is an example using the sub-matching syntax:}

        <div class="row">
          <div class="col-sm-8 offset-sm-2">
```source
where match :[left_side] {
      | \color{"x == 600"}[#e2c211] -> false
      | \color{"x == 500"}[#e2c211] -> true
      }
```
[Live example](https://bit.ly/2NaGjaK)
          </div>
        </div>

      \p{The \source{match { ... }} says to match the text bound to :[left_side] against each of the match cases \source{| match_case}, and to perform the filter on the right-hand side of the \source{->} when the pattern matches. Sub-matching statements can nest:}

        <div class="row">
          <div class="col-sm-8 offset-sm-2">
```source
where match :[left_side] {
      | \color{"x == 500"}[#e2c211] ->
            match :[right_side] {
            | \color{"x == 500"}[#e2c211] -> true
            | \color{"x == 600"}[#e2c211] -> false
            }
      | \color{"x == 600"}[#e2c211] -> false
      }
```
      </div>
</div>

\p{}
\p{}
\ph{\color{Rewrite expression syntax}[orange]}[experimental-language-features-rewrite-expression]

\p{A \source{rewrite { ... }} expression can rewrite syntax captured in a hole. This is useful for rewriting repetitions of a pattern. This example converts arguments of a `dict` to a JSON-like format, where \source{dict(foo=bar,baz=qux)} becomes \source{{"foo": bar, "baz": qux}}:}

        <div class="row">
          <div class="col-sm-4 offset-sm-2">
```match
dict(:[args])
```
          </div>

          <div class="col-sm-4">
```rewrite
:[args]
```
          </div>
        </div>


<div class="row">
  <div class="col-sm-8 offset-sm-2">
```source
where rewrite :[args] {  "\color{:[[k]]}[orange]=\color{:[[v]]}[orange]" -> "\":[k]\": :[v]" }
```
[Live example](https://bit.ly/30d3Tss)
      </div>
</div>

\p{}
\p{The pattern rewrites every matching instance of
\match{\color{:[[k]]}[orange]=\color{:[[v]]}[orange]} to \rewrite-smol{":[k]": :[v]}.
The contents of the :[args] hole are overwritten if the rewrite pattern
fires. Note that the left and right hand sides inside the \source{{ ... }} need
enclosing string quotes. This means that our pattern needs to escape the double qutes
on the right hand side.}

\p{Conceptually, a rewrite rule works the same way as a toplevel match and rewrite template, but only for a particular hole, and has the effect of overwriting the hole contents when there are substitutions.}

\p{It is possible to have sequences of rewrite expressions in a rule. Here a second rewrite expression adds quotes around :[v]:}

<div class="row">
  <div class="col-sm-8 offset-sm-2">
```source
where
rewrite :[args] {  "\color{:[[k]]}[orange]=\color{:[[v]]}[orange]" -> "\":[k]\": :[v]" },
rewrite :[args] {  ": \color{:[[v]]}[orange]" -> ": \":[v]\"" }
```
[Live example](https://bit.ly/306lB0H)
      </div>
</div>

\p{}
\p{The \source{rewrite} expressions are evaluated in a left-to-right sequence and overwrite :[args] in every case where expressions succeed. Rewrite expressions always return `true`, even if they don't succeed in rewriting a pattern. What this means for the example above is that the first rewrite expression will be attempted on :[args]. Even if it does not succeed in rewriting any patterns, the second rewrite expression will also be attempted. If neither rewrite expression change the contents of :[args], it remains unchanged in the output of the toplevel rewrite template.}

\p{It is not currently possible to nest rewrite statements, though there are plans for support in the near future. For more about future plans, see the [roadmap]{https://github.com/comby-tools/comby/blob/master/docs/ROADMAP.md}.}

  </section>

  <!-- Advanced Usage Section -->
  <section class="page-section bg-primary portfolio" id="quick-reference">
    <div class="container">

      <!-- Section Heading -->
      <h2 class="page-section-heading text-center">Quick Reference</h2>

      <!-- Line -->
      <div class="d-flex align-items-center flex-column">
        <div class="divider-line"></div>
      </div>

      \p{The project is available on GitHub: [https://github.com/comby-tools/comby]{https://github.com/comby-tools/comby}.}


      \h6{Command Line Install}[quick-install]
      \p{\rewrite{bash <(curl -sL get.comby.dev)} (Binary for Ubuntu Linux and Mac)}
      \p{\rewrite{docker pull comby/comby} (Docker)}

      \p{All the examples on [comby.live]{https://comby.live} and in the [catalog]{https://catalog.comby.dev} are just a copy away
      from working on your command-line (just click on terminal).}

      \p{}
      \h6{Quick usage}[quick-usage]

      \p{}
      \ph{\color{Replace stdin using the generic matcher (highlighted diff preview)}[orange]}[quick-stdin-generic]

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
```source
echo \color{"foo(a, b)"}[#e2c211] | comby 'foo(:[1], :[2])' 'bar(:[2], :[1])' -stdin
```
          </div>
        </div>

        \p{Output:}

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
```diff
\color{------ /dev/null}[red]
\color{++++++ /dev/null}[#13b313]
\color{@|}[gray]-1,1 +1,1 ============================================================
\bgcolor{-|}[red]\color{foo}[red](\color{a}[red], \color{b}[red])
\bgcolor{+|}[#13b313]\color{bar}[#13b313](\color{b}[#13b313], \color{a}[#13b313])
```

          </div>
        </div>

        \p{}
        \ph{\color{Highlighted diff preview for all go files in this directory and below}[orange]}[quick-diff-go-highlight]

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
```source
comby 'match :[template]' 'rewrite :[template]' .go
```
          </div>
        </div>


        \p{}
        \ph{\color{Replace <i>in place</i> for all go files in this directory and below}[orange]}[quick-replace-go-in-place]

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
```source
comby 'match :[template]' 'rewrite :[template]' .go -i
```
          </div>
        </div>

        \p{}
        \ph{\color{Add a rule for the pattern on the command line}[orange]}[quick-diff-go-highlight]

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
```source
comby 'match :[template]' 'rewrite :[template]' .go -rule 'where :[template] == \color{"main"}[#e2c211]'
```
          </div>
        </div>

      \p{}
      \ph{\color{Diff preview replacement for files ending with file.go in directory foo}[orange]}[quick-diff-preview-with-directory]

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
```source
comby 'match :[template]' 'rewrite :[template]' file.go -d foo
```
          </div>
        </div>

      \p{}
      \ph{\color{Force using the Javascript matcher for all .txt files}[orange]}[quick-force-js-for-txt]

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
```source
comby 'match :[template]' 'rewrite :[template]' .txt -matcher .js
```
          </div>
        </div>

      \p{}
      \ph{\color{Use -diff to output a plain patch (unified diff)}[orange]}[quick-diff-plain]

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">


```source
echo \color{"foo(a, b)"}[#e2c211] | comby 'foo(:[1], :[2])' 'bar(:[2], :[1])' -stdin -diff
```
          </div>
        </div>

\p{Output:}

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
```diff
--- /dev/null
+++ /dev/null
@@ -1,1 +1,1 @@
-foo(a, b)
+bar(b, a)
```
          </div>
        </div>

        \ph{\color{Use a directory of template patterns instead of the command line}[orange]}[quick-template-directory]

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">


```source
comby .go -templates /path/to/directory
```
          </div>
        </div>

        \p{A rewrite pattern should be described by two files in
        \source{path/to/directory}, one named \source{match} and the other named
        \source{rewrite}. An optional rule can be put in the same directory, in
        a file called \source{rule}. See the [catalog directory
        layout]{https://github.com/comby-tools/sample-catalog} for a [sample
        catalog of templates]{https://catalog.comby.dev}.}

    </div>
</div>


</div>
  </section>

  <!-- FAQ Section -->
  <section class="page-section bg-secondary portfolio" id="faq">
    <div class="container">

      <!-- Section Heading -->
      <h2 class="page-section-heading text-center">FAQ</h2>

      <!-- Line -->
      <div class="d-flex align-items-center flex-column">
        <div class="divider-line"></div>
      </div>

      \h6{What languages are supported?}[faq-language-support] \p{Comby supports
      basic delimiter matching for common characters like \source{()},
      \source{{}}, and \source{[]} using a generic matcher. This works as a
      fallback for data formats like JSON, new languages, and existing ones that
      may not have explicit support yet (like VHDL). The grammars for the
      following languages have been refined to take into account basic
      language-specific delimiters, comments, and string literals:}


        <div class="row">
          <div class="col-sm-10 offset-sm-1 mb-3">
            \p{`Assembly, Bash, C/C++, C#, Clojure, CSS, Dart, Elm, Elixir, Erlang,
            Fortran, F#, Go, Haskell, HTML/XML, Java, Javascript/Typescript, JSON,
            Julia, LaTeX, Lisp, OCaml, Pascal, PHP, Python, Ruby, Rust, Scala, SQL, Swift, Text`}
          </div>
        </div>

      \p{Note: Comby cannot recognize arbitrary matching tags like `&lt;foo&gt;...&lt;/foo&gt;`
      in HTML or XML yet (we do have plans to support it soon). Matching tags within angle
      brackets `<...>` works.}

      \h6{How do I extend language support?}[faq-language-extension]
      \p{Hopefully the language you're interested is already supported. If not,
          you can define your own language in a simple JSON file and pass it as a custom matcher. Just define the following supported language constructs in JSON, as follows:}


        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
```source
{
   \color{"user_defined_delimiters"}[#e2c211]:[
      [
         \color{"case"}[#e2c211],
         \color{"esac"}[#e2c211]
      ]
   ],
   \color{"escapable_string_literals"}[#e2c211]:{
      \color{"delimiters"}[#e2c211]:[
         \color{"\""}[#e2c211]
      ],
      \color{"escape_character"}[#e2c211]:\color{"\\"}[#e2c211]
   },
   \color{"raw_string_literals"}[#e2c211]: [],
   \color{"comments"}[#e2c211]:[
      [
         \color{"Multiline"}[#e2c211],
         \color{"/*"}[#e2c211],
         \color{"*/"}[#e2c211]
      ],
      [
         \color{"Until_newline"}[#e2c211],
         \color{"//"}[#e2c211]
      ]
   ]
}
```
          </div>
        </div>

        \p{Put the contents above in a JSON file, like \source{my-language.json}, and then specify your file with the \source{-custom-matcher} flag. The following runs the custom language rewrite on all files with the extension \source{.newlang}:}

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">


```source
comby -custom-matcher my-language.json 'match...' 'rewrite...' .newlang
```
          </div>
        </div>

        \p{}

          \p{If you want your missing language to be built into Comby, open a [feature
      request]{https://github.com/comby-tools/comby/issues/new/choose}, or have
      a look at the [languages
      file]{https://github.com/comby-tools/comby/blob/master/lib/matchers/languages.ml}
      which can be modified for additional languages.}

      \p{Note that languages can currently be added and expanded with respect
      to <i>syntactic</i> code structures that Comby recognizes: balanced
      delimiters, comments, and kinds of string literals. By design, it currently isn't
      possible to further refine the meaning of syntax into keywords or
      high-level structures like functions.}

        \h6{Aren't regex approaches like sed good enough?}[faq-regex-good-enough]

        \p{Sometimes, yes. But often, small changes and refactorings are
        complicated by nested expressions, comments, or strings. Consider the
        following C-like snippet. Say the challenge is to rewrite the two `if`
        conditions to the value `1`. Can you write a regular expression that
        matches the contents of the two if condition expressions, and only those
        two? Feel free to share your pattern with
        [@rvtond]{https://twitter.com/rvtond} on Twitter.}

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
```source
if (fgets(line, 128, file_pointer) == Null) // 1&rpar; if (...) returns 0
      return 0;
...
if (scanf("%d&rpar; %d", &x, &y) == 2) // 2&rpar; if (scanf("%d&rpar; %d", &x, &y) == 2) returns 0
      return 0;
```
          </div>
        </div>

        \p{To match these with comby, all you need to write is \match{if (:[condition])}, and specify one flag that this language is C-like. The
        replacement is \rewrite-smol{if (1)}. See the [live
        example]{https://bit.ly/30935ou}.}

      \h6{What can I use Comby for?}[faq-applications]
      \p{Comby is well-suited
      for matching and changing coarse syntactic structures. Uses include:}

        <div class="row">
          <div class="col-sm-10 offset-sm-1">
            \p{Custom linter checks and refactorings. See the [example
            catalog]{https://catalog.comby.dev} for checks in existing
            tools.}
          </div>
          <div class="col-sm-10 offset-sm-1">
            \p{Bug hunting. Find unchecked functions, incorrect API calls, or
            copy-paste errors with structured matching that is easier and more
            powerful than regex.}
          </div>
          <div class="col-sm-10 offset-sm-1">
            \p{Temporarily changing or removing code for tests or analyses.
            Stubbing or changing code is useful for suppressing spurious
            warnings, and for refining static analyses or fuzzing.}
          </div>
          <div class="col-sm-10 offset-sm-1">
            \p{A custom templating engine. Because Comby understands balanced
            delimiters generically, you can easily roll your own templating
            engine. This web page mixes [HTML, LaTeX-like, and Markdown-like
            syntax]{https://github.com/comby-tools/comby.dev/blob/f2d2c11d15cf192daeadd3ff6e9da647a3b98d53/index.html.dyck#L221-L232}
            to generate the final page using [custom
            templates]{https://github.com/comby-tools/comby.dev/tree/master/templates}.}.
          </div>
        </div>

      \p{Note: Comby is not well-suited to stylistic changes and formatting like
      "insert a line break after 80 characters". Pair Comby with a
      language-specific formatter to preserve formatting (like `gofmt` for the
      Go language) after performing a change.}.

      \h6{What about indentation-sensitive languages?}[faq-what-about-python]
      \p{Comby does not currently consider whitespace significant. We have plans
      to support it though! The idea is that your declarative templates will
      match on code that happens at the correct relative indentation level, for
      languages like Python. Stay tuned! Of course, a lot of Python code is not
      sensitive to whitespace indentation, so Comby is still useful (for
      example, a lot of Python 2 to Python 3 conversions can be written with
      Comby).}

        \h6{What features are planned for the future?}[faq-roadmap]
        \p{See the [roadmap in the GitHub repository]{https://github.com/comby-tools/comby/blob/master/docs/ROADMAP.md}.}

        \h6{I need help writing a pattern, or other have questions.}[faq-gitter]
        \p{Pop in at the [Gitter channel]{https://gitter.im/comby-tools/community} for more support.}



      <!--
      \h6{How does Comby compare to Regex?}[what-about-regex]

      <!--https://stackoverflow.com/questions/133601/can-regular-expressions-be-used-to-match-nested-patterns}-->

      <!--\h6{What about supporting Regex inside holes?}[language-support]-->

  </section>

  <!-- Copyright Section -->
  <section class="copyright py-4 text-center text-white">
    <div class="container">
      <div class="row">
        <div class="col-sm-12 text-center">
          <a style="color: orange" href="https://twitter.com/rvtond"><i class="fab fa-twitter"></i>@rvtond</a>
        </div>
          <div class="col-sm-12 text-center">
            <small>Copyright &copy; 2019</small>
          </div>
      </div>
    </div>
  </section>

  <!-- Scroll to Top Button (Only visible on small and extra-small screen sizes) -->
  <div class="scroll-to-top d-lg-none position-fixed ">
    <a class="js-scroll-trigger d-block text-center text-white rounded" href="#page-top">
      <i class="fa fa-chevron-up"></i>
    </a>
  </div>

  <!-- Bootstrap core JavaScript -->
  <script src="vendor/jquery/jquery.min.js"></script>
  <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

  <!-- Plugin JavaScript -->
  <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

  <!-- Custom scripts for this template -->
  <script src="js/freelancer.min.js"></script>

<script>
$(document).ready(function(){
  // Add smooth scrolling to all links
  $("a").on('click', function(event) {

    // Make sure this.hash has a value before overriding default behavior
    if (this.hash !== "") {
      // Prevent default anchor click behavior
      event.preventDefault();

      // Store hash
      var hash = this.hash;

      // Using jQuery's animate() method to add smooth page scroll
      // The optional number (800) specifies the number of milliseconds it takes to scroll to the specified area
      $('html, body').animate({
        scrollTop: $(hash).offset().top
      }, 800, function(){

        // Add hash (#) to URL when done scrolling (default click behavior)
        window.location.hash = hash;
      });
    } // End if
  });
});
</script>

</body>

</html>
