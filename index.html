<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Comby〔 Rewrite Code 〕</title>

    <!-- Custom fonts for this theme -->
    <link href="vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css">

    <!-- Theme CSS -->
    <link href="css/freelancer.min.css" rel="stylesheet">

    <!-- Source Sans Pro font -->
    <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,300italic,400italic,700italic" rel="stylesheet" type="text/css">

    <link rel="icon" href="img/favicon.ico" type="image/x-icon/">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-142487942-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-142487942-1');
    </script>

  </head>

  <body id="page-top">

    <!-- Masthead -->
    <header class="masthead bg-primary text-center">
      <div class="container masthead-container d-flex align-items-center flex-column">

        <!-- Masthead Avatar Image -->
        <!--<img class="masthead-avatar mb-5" src="img/avataaars.svg" alt="">-->

        <!-- Masthead Heading -->
        <h1 class="masthead-heading text-uppercase mb-0">Comby</h1>


        <!-- Line -->
        <div class="divider-line"></div>

        <!-- Masthead Subheading -->
        <p class="masthead-subheading font-weight-light mb-0"><code><span class="hole">a tool for changing <code><span class="hole">:[code]</span></code></span></code></p>
      </div>

      <!-- Panel -->
      <div class="container media-width-override mt-5 pl-5 pr-5">
        <div class="row">

          <!-- Basic Usage -->
          <div class="col-sm-2 offset-sm-1 panel-item">
            <a href="#basic-usage">
              <div class="mastpanel-item">
                <div class="mastpanel-item-overlay h-100 w-100">
                  <img class="img-fluid" src="img/panel/hexa-cell-1-orange.svg" alt="">
                  <p>Basic Usage</p>
                </div>
                <img class="img-fluid" src="img/panel/hexa-cell-1.svg" alt="">
                <p>Basic Usage</p>
              </div>
            </a>
          </div>

          <!-- Advanced Usage -->
          <div class="col-sm-2 panel-item">
            <a href="#advanced-usage">
              <div class="mastpanel-item">
                <div class="mastpanel-item-overlay h-100 w-100">
                  <img class="img-fluid" src="img/panel/hexa-cell-2-orange.svg" alt="">
                  <p>Advanced Usage</p>
                </div>
                <img class="img-fluid" src="img/panel/hexa-cell-2.svg" alt="">
                <p>Advanced Usage</p>
              </div>
            </a>
          </div>

          <!-- Catalog -->
          <div class="col-sm-2 panel-item">
            <a href="https://catalog.comby.dev/">
              <div class="mastpanel-item">
                <div class="mastpanel-item-overlay h-100 w-100">
                  <img class="img-fluid" src="img/panel/reading-book-orange.svg" alt="">
                  <p>Catalog</p>
                </div>
                <img class="img-fluid" src="img/panel/reading-book.svg" alt="">
                <p>Catalog</p>
              </div>
            </a>
          </div>

          <!-- Live -->
          <div class="col-sm-2 panel-item">
            <a href="https://comby.live/">
              <div class="mastpanel-item">
                <div class="mastpanel-item-overlay h-100 w-100 fucksakes">
                  <img class="img-fluid" src="img/panel/code-inspector-ui-orange.svg" alt="">
                  <p>Live</p>
                </div>
                <img class="img-fluid" src="img/panel/code-inspector-ui.svg" alt="">
                <p>Live</p>
              </div>
            </a>
          </div>

          <!-- GitHub -->
          <div class="col-sm-2 panel-item">
            <a href="https://github.com/comby-tools/comby/">
              <div class="mastpanel-item mx-auto">
                <div class="mastpanel-item-overlay h-100 w-100">
                  <img class="img-fluid" src="img/panel/github-orange.svg" alt="">
                  <p>GitHub</p>
                </div>
                <img class="img-fluid" src="img/panel/github.svg" alt="">
                <p>GitHub</p>
              </div>
            </a>
          </div>
        </div>
      </div>
    </header>

    <!-- Philosophy Section -->
    <section class="page-section bg-secondary portfolio" id="philosophy">
      <div class="container">
        <!--<h2 class="page-section-heading text-center">Philosophy</h2>-->

        <!-- Line -->
        <div class="d-flex align-items-center flex-column">
          <div class="divider-line"></div>
        </div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Code is so interesting because simple linear sequences of characters
      express rich non-linear structures (like trees) and arbitrary information
      (like comments). Humans are very creative, and have developed a variety of
      ways to order these characters to mean different things. For example,
      C-like comments can start with <code class="hl-bg-source">//</code> but Python-like comments use
      <code class="hl-bg-source">#</code>. Problematically, we use the same characters to mean different
      things across languages and in different contexts: a <code class="hl-bg-source">#</code> in C could
      be the start of a macro. Or it could be part of a string like
      <code class="hl-bg-source">"#"</code>. Or it could be a meaningless character inside a C comment
      like <code class="hl-bg-source">// #</code>. Yet at some level, a choice of characters in all
      languages correspond to similar underlying structures or information: most
      languages have comments and balanced delimiters like parentheses
      <code class="hl-bg-source">()</code> or braces <code class="hl-bg-source">{}</code> nest expressions, as found in typical
      if-statements. The key idea in Comby is to match code that respects the
      basics of this richer structure on a per-language basis, and not (only) as
      arbitrary sequences of characters. Matching sequences of characters is
      something that regex is really good for, but regex is not generally
      powerful enough to recognize nested code structures. Regex also supports a
      lot of additional functionality that can lead to complex patterns. Comby
      tries to cut down on this complexity to make changing code easy, so you'll
      find that regex-style match operators are absent in Comby. And that's OK.</p>
</div>
</div>

        <!-- Line -->
        <div class="d-flex align-items-center flex-column">
          <div class="divider-line"></div>
        </div>

      </div>
    </section>

    <!-- Basic Usage Section -->
    <section class="page-section bg-primary portfolio" id="basic-usage">
      <div class="container">

        <!-- Section Heading -->
        <h2 class="page-section-heading text-center">Basic Usage</h2>

        <!-- Line -->
        <div class="d-flex align-items-center flex-column">
          <div class="divider-line"></div>
        </div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Comby is a tool for matching and rewriting code. You start by writing
        a simple template to match syntax. Look at this Go function:</p>
</div>
</div>

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
<pre class="source"><code>func main() {
    fmt.Println("hello world")
}</code></pre>
          </div>
        </div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">We can match the arguments to <code class="hl-bg-source">fmt.Println</code> with this <i>match
        template</i>:</p>
</div>
</div>

        <div class="row">
          <div class="col-sm-6 offset-sm-3">
<pre class="match"><code>fmt.Println(<code><span class="hole">:[arguments]</span></code>)</code></pre>
          </div>
        </div>

            <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">The <code><span class="hole">:[arguments]</span></code> part is called a hole. It saves the matched part
            to a variable. In this case, the variable is
            called <code>arguments</code>, but we could have called it something
            else, like <code><span class="hole">:[1]</span></code> or <code><span class="hole">:[the_1st_arg]</span></code>. Your choice! As long as it only
            contains alphabet characters, numbers, or underscores.</p>
</div>
</div>

            <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">The <code><span class="hole">:[arguments]</span></code> hole matches the <code class="hl-bg-source">"hello world"</code> string.
            We can use it in a <i>rewrite template</i> to rewrite the function,
            like this one:</p>
</div>
</div>

        <div class="row">
          <div class="col-sm-8 offset-sm-2">
<pre class="rewrite"><code>fmt.Println(fmt.Sprintf("comby says %s", <code><span class="hole">:[arguments]</span></code>))</code></pre>
          </div>
        </div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Comby takes the match and rewrite templates and replaces the matched
        part in place:</p>
</div>
</div>

        <div class="row">
          <div class="col-sm-8 offset-sm-2">
<pre class="source"><code>func main() {
  <code class="hl-bg-rewrite">fmt.Println(fmt.Sprintf("comby says %s", "hello world"))</code>
}</code></pre>
<div class="text-right link-border"><a href="https://bit.ly/2XpttJG" target="_blank"><i class="fas fa-external-link-alt fa-fw"></i>Live example</a></div>
          </div>
        </div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Holes are the only special part in match templates, and they always
        have the form <code style="color:orange">:[...]</code>. <u>All other characters are
        interpreted literally</u> (there's a bit of detail about whitespace that
        we'll talk about in the next part). The point is that you <u>never</u>
        have to escape any characters in your template. Just say what you mean!</p>
</div>
</div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<div class="anchor-header is-active mt-3">
  <a href="##how-matching-works"><i class="fas fa-link anchor-side-link"></i><h6 id="#how-matching-works">How Matching Works</h6>
  </a>
</div>
</div>
</div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code><span class="hole">:[hole]</span></code> matches all
        characters, including newlines. If the match template
        was <i>just</i><br> <code><span class="hole">:[file_content]</span></code>, it would match all the file
        content. The way <code><span class="hole">:[hole]</span></code> starts and stops matching depends on the code
        structure around it. Let's look at an example, matching on this
        Javascript code using the match template on the right:</p>
</div>
</div>

        <div class="row">
          <div class="col-sm-5 offset-sm-2">
<pre class="source"><code>if (width <= 1280 && height <= 800) {
    return 1;
}</code></pre>
<div class="text-right link-border"><a href="https://bit.ly/2Xiw1cf" target="_blank"><i class="fas fa-external-link-alt fa-fw"></i>Live example</a></div>
          </div>

          <div class="col-sm-3">
<pre class="match"><code>if (<code><span class="hole">:[var]</span></code> <= <code><span class="hole">:[rest]</span></code>)</code></pre>
          </div>
        </div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code><span class="hole">:[var]</span></code> matches until it sees the <code class="hl-bg-source">&nbsp;<=&nbsp;</code> part coming
        after it and matches <code class="hl-bg-match">width</code>. <code><span class="hole">:[rest]</span></code> matches the rest of the
        condition: <code class="hl-bg-match">1280 && height <= 800</code>. These holes match lazily: they
        look for the shortest way to satisfy the match. One way to refine
        matching is to add concrete context around holes based on what we care
        about. For example, we could match <code class="hl-bg-match">height</code> to <code><span class="hole">:[height]</span></code> with both
        of the following templates, which depends on matching different parts of
        surrounding code:</p>
</div>
</div>

        <div class="row">
          <div class="col-sm-4 offset-sm-2">
<pre class="match"><code>if (<code><span class="hole">:[_]</span></code> && <code><span class="hole">:[height]</span></code> <code><span class="hole">:[_]</span></code>)</code></pre>
          </div>
          <div class="col-sm-4">
<pre class="match"><code>if (<code><span class="hole">:[_]</span></code> <code><span class="hole">:[height]</span></code> <= 800)</code></pre>
          </div>
        </div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<div class="anchor-header is-active mt-3">
  <a href="#about-whitespace"><i class="fas fa-link anchor-side-link"></i><h6 id="about-whitespace">About whitespace</h6>
  </a>
</div>
</div>
</div>
        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Comby tries to make matching
        code forgiving. Whitespace in the template, like a single space,
        multiple contiguous spaces, or newlines are interpreted all the same:
        Comby will match the corresponding whitespace in the source code, but
        will not care about matching the exact number of spaces, or distinguish
        between spaces and newlines. Not being strict about whitespace tends to
        be the right default decision for code in most languages. It means our
        previous match templates all still work in these cases where our
        Javascript code is formatted differently:</p>
</div>
</div>

      <div class="row">
        <div class="col-sm-4 offset-sm-2">
<pre class="source"><code>if (width <= 1280
    && height <= 800) {
    return 1;
}</code></pre>
<div class="text-right link-border"><a href="https://bit.ly/2Xh2tMk" target="_blank"><i class="fas fa-external-link-alt fa-fw"></i>Live example</a></div>
        </div>
        <div class="col-sm-4">
<pre class="source"><code>if (width     <= 1280
    && height <= 800) {
    return 1;
}</code></pre>
<div class="text-right link-border"><a href="https://bit.ly/2XaGTZV" target="_blank"><i class="fas fa-external-link-alt fa-fw"></i>Live example</a></div>
          </div>
      </div>

      <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">If you're wondering about indentation-sensitive languages like Python,
      be sure to check out the <a href="#faq-what-about-python" class="inline-a">FAQ</a>.</p>
</div>
</div>

      <div class="row">
<div class="col-sm-8 offset-sm-2">
<div class="anchor-header is-active mt-3">
  <a href="#what-makes-comby-special"><i class="fas fa-link anchor-side-link"></i><h6 id="what-makes-comby-special">What makes Comby special: More about structural matching</h6>
  </a>
</div>
</div>
</div>

      <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">If holes only matched lazily and indiscriminately up to patterns
      like <code class="hl-bg-source"><=</code> it wouldn't be much more special than matching a sequence
      of characters. But matching is smarter than that. In many languages,
      balanced delimiters like <code class="hl-bg-source">()</code>, <code class="hl-bg-source">[]</code> and <code class="hl-bg-source">{}</code>
      are <u>always</u> balanced. By default, a match template like
      <code class="hl-bg-match">(<code><span class="hole">:[1]</span></code>)</code> will only match characters <u>inside well-balanced
      parentheses</u>. Here are two example matches in this code:</p>
</div>
</div>

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
<pre class="source"><code>result = foo<code class="hl-bg-match">(<code style="color:orange">bar(x)</code>)</code> + foobar<code class="hl-bg-match">(<code style="color:orange">baz(x)</code>)</code>;</code></pre>
<div class="text-right link-border"><a href="https://bit.ly/2Xm12Mk" target="_blank"><i class="fas fa-external-link-alt fa-fw"></i>Live example</a></div>
          </div>
        </div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">The hole binds to <code class="hl-bg-source">bar(x)</code> and <code class="hl-bg-source">baz(x)</code> respectively,
        which we can easily rewrite to a different call <code class="hl-bg-source">qux(x)</code>, for
        example. The observant reader will notice that
        <code class="hl-bg-source">(<code style="color:orange">x</code>)</code> are nested matches. By default, Comby will
        match at the toplevel, but nested matches can be found with added
        context (e.g., <code class="hl-bg-match">bar(<code><span class="hole">:[1]</span></code>)</code>), or by extracting and rerunning Comby
        on modified code. Note that writing a regular expression to do the same
        is not easy (simple attempts like <code class="hl-bg-source">\(.*\)</code>
        <sup><a href="https://regexr.com/4fssh" target="_blank" style="color: orange; font-size: .75rem"><i class="fas fa-external-link-alt fa-fw"></i></a></sup> or <code class="hl-bg-source">\(.*?\)</code>
        <sup><a href="https://regexr.com/4fssk" target="_blank" style="color: orange; font-size: .75rem"><i class="fas fa-external-link-alt fa-fw"></i></a></sup> don't work).</p>
</div>
</div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Let's change the code above and make it a little more interesting.
        Suppose it was this Javascript:</p>
</div>
</div>

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
<pre class="source"><code>var result = foo(bar(x <code style="color:#ea4f00">/* arg 1) */</code>)) + foobar(<code style="color:#ea4f00">"("</code>);</code></pre>
          </div>
        </div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Now there's quite a bit of complexity if we want to match the
        arguments of <code class="hl-bg-source">foo</code> and <code class="hl-bg-source">foobar</code>. A block comment
        <code class="hl-bg-source"><code style="color:#ea4f00">/* arg 1) */</code></code> is inlined
        for <code class="hl-bg-source">bar</code>. Because this is a comment, it shouldn't matter whether
        the parenthesis inside are balanced or not. The same goes for the string
        literal argument to <code class="hl-bg-source">foobar</code>: it's not a parenthesis in the code.
        The special thing here is that our original match template
        <code class="hl-bg-match">(<code><span class="hole">:[1]</span></code>)</code> can stay <u>exactly the same</u> and still matches the
        two arguments (in this case, it captures the comment and string)</p>
</div>
</div>

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
<pre class="source"><code>var result = foo<code class="hl-bg-match">(<code style="color:orange">bar(x /* arg 1) */)</code>)</code> + foobar(<code class="hl-bg-match"><code style="color:orange">"("</code></code>);</code></pre>
<div class="text-right link-border"><a href="https://bit.ly/2Zy5PYG" target="_blank"><i class="fas fa-external-link-alt fa-fw"></i>Live example</a></div>
          </div>
        </div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Comby understands this interaction between delimiters, strings, and
        comments and makes reasonable guesses for your language based on file
        extension (you can also force a particular matcher with a command line
        option, see the <a href="#quick-reference" class="inline-a">Quick Reference</a>). And, you can
        always fall back to a generic matcher for files or languages that are
        not explicitly supported. See the <a href="#faq-language-support" class="inline-a">FAQ</a> for
        language support and extension.</p>
</div>
</div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Note that if we tried to use a regex above, our pattern would need to
        understand that <code class="hl-bg-source">/* */</code> delineates comments, otherwise it would
        get confused by the parenthesis inside! The same problem comes up for
        the string literal argument, which contains an unbalanced parenthesis. A
        regular expression that takes all of this into account would get ugly
        fast, and that's only for Javascript!</p>
</div>
</div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<div class="anchor-header is-active mt-3">
  <a href="#match-syntax"><i class="fas fa-link anchor-side-link"></i><h6 id="match-syntax">Match Syntax Reference</h6>
  </a>
</div>
</div>
</div>
        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">The following syntax is
        supported in Comby, and carry special meaning for matching:</p>
</div>
</div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code class="hl-bg-source"><code><span class="hole">:[hole]</span></code></code> matches zero or more <i>well-balanced</i> characters
        until the part that comes after the hole (like whitespace, or some other
        string) in a lazy fashion. When <code><span class="hole">:[hole]</span></code> is inside delimiters, as in
        <code>(<code><span class="hole">:[hole]</span></code>)</code>, it matches (only) within those delimiters.</p>
</div>
</div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code class="hl-bg-source"><code style="color:orange">:[[hole]]</code></code> matches one or more alphanumeric
        characters and <code>_</code>.</p>
</div>
</div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code class="hl-bg-source"><code style="color:orange">:[hole.]</code></code> (with a period at the end) matches
        one or more alphanumeric characters and punctuation (like <code>.</code>, <code>;</code>, and
        <code>-</code>).</p>
</div>
</div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code class="hl-bg-source"><code style="color:orange">:[hole\n]</code></code> (with a <code>\n</code> at the end) matches one or more
        characters up to a newline.</p>
</div>
</div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code class="hl-bg-source"><code style="color:orange">:[ ]</code></code> (with a space) matches only whitespace
        characters, excluding newlines. To assign the matched whitespace to
        variable, put the variable name after the space, like <code style="color:orange">:[
        white]</code>.</p>
</div>
</div>


        <div class="row">
<div class="col-sm-8 offset-sm-2">
<div class="anchor-header is-active mt-3">
  <a href="#tips-and-tricks"><i class="fas fa-link anchor-side-link"></i><h6 id="tips-and-tricks">A few more tips and tricks</h6>
  </a>
</div>
</div>
</div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code style="color:orange"><i class="fas fa-lightbulb"></i>&nbsp;</code> Using <code><span class="hole">:[hole]</span></code> inside
        string quotes will match only within the string. This is implemented for
        <a href="#faq-language-support" class="inline-a">most languages</a>. Comby also understands the
        difference between escapable string literals (like
        <code>"string"</code> in C) and raw string literals (like
        <code>`string`</code> in Go), and will know to stop between these
        delimiters. <sup><a href="https://bit.ly/2WRnxEL" target="_blank" style="color: orange; font-size: .75rem"><i class="fas fa-external-link-alt fa-fw"></i></a></sup></p>
</div>
</div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code style="color:orange"><i class="fas fa-lightbulb"></i>&nbsp;</code>
        Use <code style="color:orange">:[[hole]]</code> to match only alphanumeric and
        underscore characters. This hole does not match across newlines or
        punctuation.<sup><a href="https://bit.ly/2WUhPCa" target="_blank" style="color: orange; font-size: .75rem"><i class="fas fa-external-link-alt fa-fw"></i></a></sup></p>
</div>
</div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code style="color:orange"><i class="fas fa-lightbulb"></i>&nbsp;</code>
        You can refer to the same variable using either
        <code style="color:orange">:[[hole]]</code> or <code><span class="hole">:[hole]</span></code> in the rewrite template.
        <sup><a href="https://bit.ly/2ZAQZR0" target="_blank" style="color: orange; font-size: .75rem"><i class="fas fa-external-link-alt fa-fw"></i></a></sup></p>
</div>
</div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code style="color:orange"><i class="fas fa-lightbulb"></i>&nbsp;</code>
        You almost never want to start a template with <code><span class="hole">:[hole]</span></code>, since it
        matches everything including newlines up to its suffix. This can make
        things slow. <code><span class="hole">:[hole]</span></code> is typically useful inside balanced delimiters.<sup><a href="https://bit.ly/2WVDzh7" target="_blank" style="color: orange; font-size: .75rem"><i class="fas fa-external-link-alt fa-fw"></i></a></sup></p>
</div>
</div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code style="color:orange"><i class="fas fa-lightbulb"></i>&nbsp;</code> Consider
        combinations of holes to match interesting properties. For example, to
        capture leading indentation of a line, use a template like <br><code style="color:orange">:[
        leading_indentation]<code><span class="hole">:[everything_until_newline]</span></code></code>.<sup><a href="https://bit.ly/2XOpczz" target="_blank" style="color: orange; font-size: .75rem"><i class="fas fa-external-link-alt fa-fw"></i></a></sup></p>
</div>
</div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code style="color:orange"><i class="fas fa-lightbulb"></i>&nbsp;</code> Looking for
        inspiration? Check out these simple code
        rewrites<sup><a href="https://catalog.comby.dev/" target="_blank" style="color: orange; font-size: .75rem"><i class="fas fa-external-link-alt fa-fw"></i></a></sup> and the <a href="#faq-applications" class="inline-a">FAQ</a>.</p>
</div>
</div>

        </div>
      </div>


  </section>

  <!-- Advanced Usage Section -->
  <section class="page-section bg-secondary portfolio" id="advanced-usage">
    <div class="container">

      <!-- Section Heading -->
      <h2 class="page-section-heading text-center">Advanced Usage</h2>

      <!-- Line -->
      <div class="d-flex align-items-center flex-column">
        <div class="divider-line"></div>
      </div>

      <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">You can refine matches and rewrite templates with <i>rules</i> in Comby. Rules start with the word <code class="hl-bg-source">where</code>. A rule can check whether two variables are syntactically equal. For example, we can check for duplicate expressions in if-conditions with the following match template and rule:</p>
</div>
</div>

        <div class="row">
          <div class="col-sm-8 offset-sm-2">
<pre class="match"><code>if (<code><span class="hole">:[left_side]</span></code> && <code><span class="hole">:[right_side]</span></code>)</code></pre>
          </div>
        </div>

        <div class="row">
          <div class="col-sm-4 offset-sm-2">
<pre class="source"><code>where <code><span class="hole">:[left_side]</span></code> == <code><span class="hole">:[right_side]</span></code></code></pre>
          </div>
        </div>

<div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">This matches code where the programmer perhaps made a mistake and duplicated an expression without changing a variable like <code class="hl-bg-source">x</code> to <code class="hl-bg-source">y</code>:</p>
</div>
</div>

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
<pre class="source"><code>if (<code class="hl-bg-match">x == 500</code> && <code class="hl-bg-match">x == 500</code>)</code></pre>
<div class="text-right link-border"><a href="https://bit.ly/2Na9UAS" target="_blank"><i class="fas fa-external-link-alt fa-fw"></i>Live example</a></div>
          </div>
        </div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">You can use the <code class="hl-bg-source">!=</code> operator to check inequality. Multiple conditions can be separated by a comma, and mean "logical and". The following adds a condition to ignore our match case above:</p>
</div>
</div>

        <div class="row">
          <div class="col-sm-8 offset-sm-2">
<pre class="source"><code>where <code><span class="hole">:[left_side]</span></code> == <code><span class="hole">:[right_side]</span></code>, <code><span class="hole">:[left_side]</span></code> != <code style="color:#ea4f00">"x == 500"</code></code></pre>
<div class="text-right link-border"><a href="https://bit.ly/2NaaCOy" target="_blank"><i class="fas fa-external-link-alt fa-fw"></i>Live example</a></div>
          </div>
        </div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Variables can be compared to other variables or string contents (enclosed by double quotes).</p>
</div>
</div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<div class="anchor-header is-active mt-3">
  <a href="#experimental-language-features"><i class="fas fa-link anchor-side-link"></i><h6 id="experimental-language-features">Experimental language features</h6>
  </a>
</div>
</div>
</div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Comby includes experimental language features for sub-matching on variables. These features might change, but are currently available if you want to experiment with it. Here is an example using the sub-matching syntax:</p>
</div>
</div>

        <div class="row">
          <div class="col-sm-8 offset-sm-2">
<pre class="source"><code>where match <code><span class="hole">:[left_side]</span></code> {
      | <code style="color:#ea4f00">"x == 600"</code> -> false
      | <code style="color:#ea4f00">"x == 500"</code> -> true
      }</code></pre>
<div class="text-right link-border"><a href="https://bit.ly/2NaGjaK" target="_blank"><i class="fas fa-external-link-alt fa-fw"></i>Live example</a></div>
          </div>
        </div>

      <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">The <code class="hl-bg-source">match { ... }</code> says to match the text bound to <code><span class="hole">:[left_side]</span></code> against each of the match cases <code class="hl-bg-source">| match_case</code>, and to perform the filter on the right-hand side of the <code class="hl-bg-source">-></code> when the pattern matches. Sub-matching statements can nest:</p>
</div>
</div>

        <div class="row">
          <div class="col-sm-8 offset-sm-2">
<pre class="source"><code>where match <code><span class="hole">:[left_side]</span></code> {
      | <code style="color:#ea4f00">"x == 500"</code> ->
            match <code><span class="hole">:[right_side]</span></code> {
            | <code style="color:#ea4f00">"x == 500"</code> -> true
            | <code style="color:#ea4f00">"x == 600"</code> -> false
            }
      | <code style="color:#ea4f00">"x == 600"</code> -> false
      }</code></pre>
                                                                    </div>
</div>

  </section>

  <!-- Advanced Usage Section -->
  <section class="page-section bg-primary portfolio" id="quick-reference">
    <div class="container">

      <!-- Section Heading -->
      <h2 class="page-section-heading text-center">Quick Reference</h2>

      <!-- Line -->
      <div class="d-flex align-items-center flex-column">
        <div class="divider-line"></div>
      </div>

      <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">All the examples on <a href="https://comby.live" class="inline-a">comby.live</a> and in the <a href="https://catalog.comby.dev" class="inline-a">catalog</a> are just a copy away
      from working on your command-line (just click on terminal). Install:</p>
</div>
</div>

      <div class="offset-sm-3"><div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code class="hl-bg-rewrite">bash <(curl -sL get.comby.dev)</code></p>
</div>
</div></div>

      <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Here are some basics:</p>
</div>
</div>

      <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code style="color:orange">Replace stdin using the generic matcher (highlighted diff preview)</code></p>
</div>
</div>

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
<pre class="source"><code>echo "foo(a, b)" | comby 'foo(<code><span class="hole">:[1]</span></code>, <code><span class="hole">:[2]</span></code>)' 'bar(<code><span class="hole">:[2]</span></code>, <code><span class="hole">:[1]</span></code>)' -stdin</code></pre>
          </div>
        </div>

<div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Output:</p>
</div>
</div>

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
<pre class="diff"><code><code style="color:#ea4f00">------ /dev/null</code>
<code style="color:#13b313">++++++ /dev/null</code>
<code style="color:gray">@|</code>-1,1 +1,1 ============================================================
<code style="background-color:#ea4f00">-|</code><code style="color:#ea4f00">foo</code>(<code style="color:#ea4f00">a</code>, <code style="color:#ea4f00">b</code>)
<code style="background-color:#13b313">+|</code><code style="color:#13b313">bar</code>(<code style="color:#13b313">b</code>, <code style="color:#13b313">a</code>)</code></pre>

          </div>
        </div>

      <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code style="color:orange">Highlighted diff preview for all go files in this directory and below</code></p>
</div>
</div>

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
<pre class="source"><code>comby 'match <code><span class="hole">:[template]</span></code>' 'rewrite <code><span class="hole">:[template]</span></code>' .go</code></pre>
          </div>
        </div>

      <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code style="color:orange">Replace <i>in place</i> for all go files in this directory and below</code></p>
</div>
</div>

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
<pre class="source"><code>comby 'match <code><span class="hole">:[template]</span></code>' 'rewrite <code><span class="hole">:[template]</span></code>' .go -i</code></pre>
          </div>
        </div>

      <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code style="color:orange">Diff preview replacement for files ending with file.go in directory foo</code></p>
</div>
</div>

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
<pre class="source"><code>comby 'match <code><span class="hole">:[template]</span></code>' 'rewrite <code><span class="hole">:[template]</span></code>' file.go -d foo</code></pre>
          </div>
        </div>

      <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code style="color:orange">Force using the Javascript matcher for all .txt files</code></p>
</div>
</div>

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
<pre class="source"><code>comby 'match <code><span class="hole">:[template]</span></code>' 'rewrite <code><span class="hole">:[template]</span></code>' .txt -matcher .js</code></pre>
          </div>
        </div>


      <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code style="color:orange">Use -diff to output a plain patch (unified diff)</code></p>
</div>
</div>

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">


<pre class="source"><code>echo "foo(a, b)" | comby 'foo(<code><span class="hole">:[1]</span></code>, <code><span class="hole">:[2]</span></code>)' 'bar(<code><span class="hole">:[2]</span></code>, <code><span class="hole">:[1]</span></code>)' -stdin -diff</code></pre>
          </div>
        </div>

<div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Output:</p>
</div>
</div>

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">
<pre class="diff"><code>--- /dev/null
+++ /dev/null
@@ -1,1 +1,1 @@
-foo(a, b)
+bar(b, a)</code></pre>
          </div>
        </div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code style="color:orange">Use a directory of template patterns instead of the command line</code></p>
</div>
</div>

        <div class="row">
          <div class="col-sm-8 offset-sm-2 mb-3">


<pre class="source"><code>comby .go -templates /path/to/directory</code></pre>
          </div>
        </div>

        <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">A rewrite pattern should be described by two files in
        <code class="hl-bg-source">path/to/directory</code>, one named <code class="hl-bg-source">match</code> and the other named
        <code class="hl-bg-source">rewrite</code>. An optional rule can be put in the same directory, in
        a file called <code class="hl-bg-source">rule</code>. See the <a href="https://github.com/comby-tools/sample-catalog" class="inline-a">catalog directory
        layout</a> for a <a href="https://catalog.comby.dev" class="inline-a">sample
        catalog of templates</a>.</p>
</div>
</div>

    </div>
</div>


</div>
  </section>

  <!-- FAQ Section -->
  <section class="page-section bg-secondary portfolio" id="faq">
    <div class="container">

      <!-- Section Heading -->
      <h2 class="page-section-heading text-center">FAQ</h2>

      <!-- Line -->
      <div class="d-flex align-items-center flex-column">
        <div class="divider-line"></div>
      </div>

      <div class="row">
<div class="col-sm-8 offset-sm-2">
<div class="anchor-header is-active mt-3">
  <a href="#faq-language-support"><i class="fas fa-link anchor-side-link"></i><h6 id="faq-language-support">What languages are supported?</h6>
  </a>
</div>
</div>
</div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Comby supports
      basic delimiter matching for common characters like <code class="hl-bg-source">()</code>,
      <code class="hl-bg-source">{}</code>, and <code class="hl-bg-source">[]</code> using a generic matcher. This works as a
      fallback for data formats like JSON, new languages, and existing ones that
      may not have explicit support yet (like VHDL). The grammars for the
      following languages have been refined to take into account basic
      language-specific delimiters, comments, and string literals:</p>
</div>
</div>


        <div class="row">
          <div class="col-sm-10 offset-sm-1 mb-3">
            <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Assembly, Bash, CSS, Clojure, C#, Dart, Elixir, Elm, Erlang,
      Fortran, F#, Go, Haskell, HTML/XML, Java, Javascript/Typescript, JSON,
      Julia, LaTeX, OCaml, Pascal, PHP, Python, Ruby, Rust, SQL, Scala, Swift</p>
</div>
</div>
          </div>
        </div>

      <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Note: Comby cannot recognize arbitrary matching tags like <code>&lt;foo&gt;...&lt;/foo&gt;</code>
      in HTML or XML yet (we do have plans to support it soon). Matching within angle
      brackets <code><...></code> works.</p>
</div>
</div>

      <div class="row">
<div class="col-sm-8 offset-sm-2">
<div class="anchor-header is-active mt-3">
  <a href="#faq-language-extension"><i class="fas fa-link anchor-side-link"></i><h6 id="faq-language-extension">How do I extend language support?</h6>
  </a>
</div>
</div>
</div>
      <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Hopefully the language you're interested is already supported. If not,
      open a <a href="https://github.com/comby-tools/comby/issues/new/choose" class="inline-a">feature
      request</a>, or have
      a look at the <a href="https://github.com/comby-tools/comby/blob/master/lib/matchers/languages.ml" class="inline-a">languages
      file</a>
      which can be modified for additional languages.</p>
</div>
</div>

      <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Note that languages can currently be added and expanded with respect
      to <i>syntactic</i> code strctures that Comby recognizes: balanced
      delimiters, comments, and kinds of string literals. By design, it isn't
      possible to further refine the meaning of syntax into keywords or
      high-level structures like functions.</p>
</div>
</div>

      <div class="row">
<div class="col-sm-8 offset-sm-2">
<div class="anchor-header is-active mt-3">
  <a href="#faq-applications"><i class="fas fa-link anchor-side-link"></i><h6 id="faq-applications">What can I use Comby for?</h6>
  </a>
</div>
</div>
</div>
      <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Comby is well-suited
      for matching and changing coarse syntactic structures. Uses include:</p>
</div>
</div>

        <div class="row">
          <div class="col-sm-10 offset-sm-1">
            <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Custom linter checks and refactorings. See the <a href="https://catalog.comby.dev" class="inline-a">example
            catalog</a> for checks in existing
            tools.</p>
</div>
</div>
          </div>
          <div class="col-sm-10 offset-sm-1">
            <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Bug hunting. Find unchecked functions, incorrect API calls, or
            copy-paste errors with structured matching that is easier and more
            powerful than regex.</p>
</div>
</div>
          </div>
          <div class="col-sm-10 offset-sm-1">
            <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Temporarily changing or removing code for tests or analyses.
            Stubbing or changing code is useful for suppressing spurious
            warnings, and in refining static analyses or fuzzing.</p>
</div>
</div>
          </div>
          <div class="col-sm-10 offset-sm-1">
            <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">A custom templating engine. Because Comby understands balanced
            delimiters generically, you can easily roll your own templating
            engine. This web page mixes <a href="https://github.com/comby-tools/comby.dev/blob/f2d2c11d15cf192daeadd3ff6e9da647a3b98d53/index.html.dyck#L221-L232" class="inline-a">HTML, LaTeX-like, and Markdown-like
            syntax</a>
            to generate the final page using <a href="https://github.com/comby-tools/comby.dev/tree/master/templates" class="inline-a">custom
            templates</a>.</p>
</div>
</div>.
          </div>
        </div>

      <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Note: Comby is not well-suited to stylistic changes and formatting like
      "insert a line break after 80 characters". Pair Comby with a
      language-specific formatter to preserve formatting (like <code>gofmt</code> for the
      Go language) after performing a change.</p>
</div>
</div>.

      <div class="row">
<div class="col-sm-8 offset-sm-2">
<div class="anchor-header is-active mt-3">
  <a href="#faq-what-about-python"><i class="fas fa-link anchor-side-link"></i><h6 id="faq-what-about-python">What about indentation-sensitive languages?</h6>
  </a>
</div>
</div>
</div>
      <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Comby does not currently consider whitespace significant. We have plans
      to support it though! The idea is that your declarative templates will
      match on code that happens at the correct relative indentation level, for
      languages like Python. Stay tuned! Of course, a lot of Python code is not
      sensitive to whitespace indentation, so Comby is still useful (for
      example, a lot of Python 2 to Python 3 conversions can be written with
      Comby).</p>
</div>
</div>

      <!--<div class="row">
<div class="col-sm-8 offset-sm-2">
<div class="anchor-header is-active mt-3">
  <a href="#faq-gitter"><i class="fas fa-link anchor-side-link"></i><h6 id="faq-gitter">I need more info</h6>
  </a>
</div>
</div>
</div><div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"> Pop in at the gitter</p>
</div>
</div>-->

      <!--
      <div class="row">
<div class="col-sm-8 offset-sm-2">
<div class="anchor-header is-active mt-3">
  <a href="#what-about-regex"><i class="fas fa-link anchor-side-link"></i><h6 id="what-about-regex">How does Comby compare to Regex?</h6>
  </a>
</div>
</div>
</div>
      <!--https://stackoverflow.com/questions/133601/can-regular-expressions-be-used-to-match-nested-patterns}-->

      <!--<div class="row">
<div class="col-sm-8 offset-sm-2">
<div class="anchor-header is-active mt-3">
  <a href="#language-support"><i class="fas fa-link anchor-side-link"></i><h6 id="language-support">What about supporting Regex inside holes?</h6>
  </a>
</div>
</div>
</div>-->

  </section>

  <!-- Copyright Section -->
  <section class="copyright py-4 text-center text-white">
    <div class="container">
      <div class="row">
        <div class="col-sm-12 text-center">
          <a style="color: orange" href="https://twitter.com/rvtond"><i class="fab fa-twitter"></i>@rvtond</a>
        </div>
          <div class="col-sm-12 text-center">
            <small>Copyright &copy; 2019</small>
          </div>
      </div>
    </div>
  </section>

  <!-- Scroll to Top Button (Only visible on small and extra-small screen sizes) -->
  <div class="scroll-to-top d-lg-none position-fixed ">
    <a class="js-scroll-trigger d-block text-center text-white rounded" href="#page-top">
      <i class="fa fa-chevron-up"></i>
    </a>
  </div>

  <!-- Bootstrap core JavaScript -->
  <script src="vendor/jquery/jquery.min.js"></script>
  <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

  <!-- Plugin JavaScript -->
  <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

  <!-- Custom scripts for this template -->
  <script src="js/freelancer.min.js"></script>

<script>
$(document).ready(function(){
  // Add smooth scrolling to all links
  $("a").on('click', function(event) {

    // Make sure this.hash has a value before overriding default behavior
    if (this.hash !== "") {
      // Prevent default anchor click behavior
      event.preventDefault();

      // Store hash
      var hash = this.hash;

      // Using jQuery's animate() method to add smooth page scroll
      // The optional number (800) specifies the number of milliseconds it takes to scroll to the specified area
      $('html, body').animate({
        scrollTop: $(hash).offset().top
      }, 800, function(){

        // Add hash (#) to URL when done scrolling (default click behavior)
        window.location.hash = hash;
      });
    } // End if
  });
});
</script>

</body>

</html>
